<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>tinycolor.mjs - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="wsemi.html">wsemi</a><ul class='methods'><li data-type='method'><a href="wsemi.html#.ab2blob">ab2blob</a></li><li data-type='method'><a href="wsemi.html#.ab2u8arr">ab2u8arr</a></li><li data-type='method'><a href="wsemi.html#.addMonth">addMonth</a></li><li data-type='method'><a href="wsemi.html#.aes2str">aes2str</a></li><li data-type='method'><a href="wsemi.html#.alive">alive</a></li><li data-type='method'><a href="wsemi.html#.arr2dt">arr2dt</a></li><li data-type='method'><a href="wsemi.html#.arraccum">arraccum</a></li><li data-type='method'><a href="wsemi.html#.arradd">arradd</a></li><li data-type='method'><a href="wsemi.html#.arrat">arrat</a></li><li data-type='method'><a href="wsemi.html#.arrfind">arrfind</a></li><li data-type='method'><a href="wsemi.html#.arrhas">arrhas</a></li><li data-type='method'><a href="wsemi.html#.b642obj">b642obj</a></li><li data-type='method'><a href="wsemi.html#.b642str">b642str</a></li><li data-type='method'><a href="wsemi.html#.b642u8arr">b642u8arr</a></li><li data-type='method'><a href="wsemi.html#.b642u16arr">b642u16arr</a></li><li data-type='method'><a href="wsemi.html#.binstr">binstr</a></li><li data-type='method'><a href="wsemi.html#.blob2ab">blob2ab</a></li><li data-type='method'><a href="wsemi.html#.blob2b64">blob2b64</a></li><li data-type='method'><a href="wsemi.html#.blob2str">blob2str</a></li><li data-type='method'><a href="wsemi.html#.blob2u8arr">blob2u8arr</a></li><li data-type='method'><a href="wsemi.html#.blobs2b64s">blobs2b64s</a></li><li data-type='method'><a href="wsemi.html#.blobs2u8arrs">blobs2u8arrs</a></li><li data-type='method'><a href="wsemi.html#.bodyLog">bodyLog</a></li><li data-type='method'><a href="wsemi.html#.browserView">browserView</a></li><li data-type='method'><a href="wsemi.html#.browserViewFromBlob">browserViewFromBlob</a></li><li data-type='method'><a href="wsemi.html#.browserViewFromText">browserViewFromText</a></li><li data-type='method'><a href="wsemi.html#.browserViewFromU8arr">browserViewFromU8arr</a></li><li data-type='method'><a href="wsemi.html#.bs2u8arr">bs2u8arr</a></li><li data-type='method'><a href="wsemi.html#.bufRead">bufRead</a></li><li data-type='method'><a href="wsemi.html#.bufReadDbl">bufReadDbl</a></li><li data-type='method'><a href="wsemi.html#.bufWrite">bufWrite</a></li><li data-type='method'><a href="wsemi.html#.bufWriteDbl">bufWriteDbl</a></li><li data-type='method'><a href="wsemi.html#.cache">cache</a></li><li data-type='method'><a href="wsemi.html#.cbol">cbol</a></li><li data-type='method'><a href="wsemi.html#.cdbl">cdbl</a></li><li data-type='method'><a href="wsemi.html#.cfilesize">cfilesize</a></li><li data-type='method'><a href="wsemi.html#.cfinancial">cfinancial</a></li><li data-type='method'><a href="wsemi.html#.cint">cint</a></li><li data-type='method'><a href="wsemi.html#.clearXSS">clearXSS</a></li><li data-type='method'><a href="wsemi.html#.copyStrToClipboard">copyStrToClipboard</a></li><li data-type='method'><a href="wsemi.html#.cstr">cstr</a></li><li data-type='method'><a href="wsemi.html#.day2cht">day2cht</a></li><li data-type='method'><a href="wsemi.html#.debounce">debounce</a></li><li data-type='method'><a href="wsemi.html#.delay">delay</a></li><li data-type='method'><a href="wsemi.html#.dig">dig</a></li><li data-type='method'><a href="wsemi.html#.digExp">digExp</a></li><li data-type='method'><a href="wsemi.html#.domAlert">domAlert</a></li><li data-type='method'><a href="wsemi.html#.domAppend">domAppend</a></li><li data-type='method'><a href="wsemi.html#.domCancelEvent">domCancelEvent</a></li><li data-type='method'><a href="wsemi.html#.domDetect">domDetect</a></li><li data-type='method'><a href="wsemi.html#.domDrag">domDrag</a></li><li data-type='method'><a href="wsemi.html#.domDragBarAndScroll">domDragBarAndScroll</a></li><li data-type='method'><a href="wsemi.html#.domDropFiles">domDropFiles</a></li><li data-type='method'><a href="wsemi.html#.domFadeIn">domFadeIn</a></li><li data-type='method'><a href="wsemi.html#.domFadeOut">domFadeOut</a></li><li data-type='method'><a href="wsemi.html#.domFind">domFind</a></li><li data-type='method'><a href="wsemi.html#.domFinds">domFinds</a></li><li data-type='method'><a href="wsemi.html#.domGetFileAccept">domGetFileAccept</a></li><li data-type='method'><a href="wsemi.html#.domGetFiles">domGetFiles</a></li><li data-type='method'><a href="wsemi.html#.domGetPointFromEvent">domGetPointFromEvent</a></li><li data-type='method'><a href="wsemi.html#.domGetScrollableParent">domGetScrollableParent</a></li><li data-type='method'><a href="wsemi.html#.domIsClientXYIn">domIsClientXYIn</a></li><li data-type='method'><a href="wsemi.html#.domRemove">domRemove</a></li><li data-type='method'><a href="wsemi.html#.domShowInputAndGetFiles">domShowInputAndGetFiles</a></li><li data-type='method'><a href="wsemi.html#.domShowInputAndGetFilesU8Arrs">domShowInputAndGetFilesU8Arrs</a></li><li data-type='method'><a href="wsemi.html#.domTooltip">domTooltip</a></li><li data-type='method'><a href="wsemi.html#.domTriggerEvent">domTriggerEvent</a></li><li data-type='method'><a href="wsemi.html#.downloadExcelFileFromData">downloadExcelFileFromData</a></li><li data-type='method'><a href="wsemi.html#.downloadExcelFileFromDataDyn">downloadExcelFileFromDataDyn</a></li><li data-type='method'><a href="wsemi.html#.downloadFileFromB64">downloadFileFromB64</a></li><li data-type='method'><a href="wsemi.html#.downloadFileFromBlob">downloadFileFromBlob</a></li><li data-type='method'><a href="wsemi.html#.downloadFileFromText">downloadFileFromText</a></li><li data-type='method'><a href="wsemi.html#.downloadFileFromU8Arr">downloadFileFromU8Arr</a></li><li data-type='method'><a href="wsemi.html#.dtmapping">dtmapping</a></li><li data-type='method'><a href="wsemi.html#.dtpick">dtpick</a></li><li data-type='method'><a href="wsemi.html#.evem">evem</a></li><li data-type='method'><a href="wsemi.html#.execScript">execScript</a></li><li data-type='method'><a href="wsemi.html#.f2c">f2c</a></li><li data-type='method'><a href="wsemi.html#.files2data">files2data</a></li><li data-type='method'><a href="wsemi.html#.fsCleanFolder">fsCleanFolder</a></li><li data-type='method'><a href="wsemi.html#.fsCopyFolder">fsCopyFolder</a></li><li data-type='method'><a href="wsemi.html#.fsCreateFolder">fsCreateFolder</a></li><li data-type='method'><a href="wsemi.html#.fsDeleteFolder">fsDeleteFolder</a></li><li data-type='method'><a href="wsemi.html#.fsGetFilesInFolder">fsGetFilesInFolder</a></li><li data-type='method'><a href="wsemi.html#.fsGetFoldersInFolder">fsGetFoldersInFolder</a></li><li data-type='method'><a href="wsemi.html#.fsIsFile">fsIsFile</a></li><li data-type='method'><a href="wsemi.html#.fsIsFolder">fsIsFolder</a></li><li data-type='method'><a href="wsemi.html#.fsReadText">fsReadText</a></li><li data-type='method'><a href="wsemi.html#.fsTreeFolder">fsTreeFolder</a></li><li data-type='method'><a href="wsemi.html#.fsWriteText">fsWriteText</a></li><li data-type='method'><a href="wsemi.html#.genGradientColor">genGradientColor</a></li><li data-type='method'><a href="wsemi.html#.genID">genID</a></li><li data-type='method'><a href="wsemi.html#.genPm">genPm</a></li><li data-type='method'><a href="wsemi.html#.getBufferSize">getBufferSize</a></li><li data-type='method'><a href="wsemi.html#.getDataFromExcelFileU8Arr">getDataFromExcelFileU8Arr</a></li><li data-type='method'><a href="wsemi.html#.getDataFromExcelFileU8ArrDyn">getDataFromExcelFileU8ArrDyn</a></li><li data-type='method'><a href="wsemi.html#.getEnv">getEnv</a></li><li data-type='method'><a href="wsemi.html#.getFileAccept">getFileAccept</a></li><li data-type='method'><a href="wsemi.html#.getGlobal">getGlobal</a></li><li data-type='method'><a href="wsemi.html#.getltdtkeys">getltdtkeys</a></li><li data-type='method'><a href="wsemi.html#.getObjSize">getObjSize</a></li><li data-type='method'><a href="wsemi.html#.getTimeBetween">getTimeBetween</a></li><li data-type='method'><a href="wsemi.html#.getTimeFromUnit">getTimeFromUnit</a></li><li data-type='method'><a href="wsemi.html#.getTimeObject">getTimeObject</a></li><li data-type='method'><a href="wsemi.html#.getTimeRange">getTimeRange</a></li><li data-type='method'><a href="wsemi.html#.getUserAgent">getUserAgent</a></li><li data-type='method'><a href="wsemi.html#.getUserAgentDyn">getUserAgentDyn</a></li><li data-type='method'><a href="wsemi.html#.haskey">haskey</a></li><li data-type='method'><a href="wsemi.html#.hsl">hsl</a></li><li data-type='method'><a href="wsemi.html#.html2pic">html2pic</a></li><li data-type='method'><a href="wsemi.html#.html2picDyn">html2picDyn</a></li><li data-type='method'><a href="wsemi.html#.htmlDecode">htmlDecode</a></li><li data-type='method'><a href="wsemi.html#.htmlEncode">htmlEncode</a></li><li data-type='method'><a href="wsemi.html#.importResources">importResources</a></li><li data-type='method'><a href="wsemi.html#.isab">isab</a></li><li data-type='method'><a href="wsemi.html#.isarr">isarr</a></li><li data-type='method'><a href="wsemi.html#.isarr0">isarr0</a></li><li data-type='method'><a href="wsemi.html#.isblob">isblob</a></li><li data-type='method'><a href="wsemi.html#.isbol">isbol</a></li><li data-type='method'><a href="wsemi.html#.isday">isday</a></li><li data-type='method'><a href="wsemi.html#.isDev">isDev</a></li><li data-type='method'><a href="wsemi.html#.isearr">isearr</a></li><li data-type='method'><a href="wsemi.html#.isEle">isEle</a></li><li data-type='method'><a href="wsemi.html#.isEleExistByID">isEleExistByID</a></li><li data-type='method'><a href="wsemi.html#.isEmail">isEmail</a></li><li data-type='method'><a href="wsemi.html#.iseobj">iseobj</a></li><li data-type='method'><a href="wsemi.html#.iser">iser</a></li><li data-type='method'><a href="wsemi.html#.isernot">isernot</a></li><li data-type='method'><a href="wsemi.html#.isestr">isestr</a></li><li data-type='method'><a href="wsemi.html#.isfun">isfun</a></li><li data-type='method'><a href="wsemi.html#.isint">isint</a></li><li data-type='method'><a href="wsemi.html#.ismonth">ismonth</a></li><li data-type='method'><a href="wsemi.html#.isn0int">isn0int</a></li><li data-type='method'><a href="wsemi.html#.isn0num">isn0num</a></li><li data-type='method'><a href="wsemi.html#.isNarrow">isNarrow</a></li><li data-type='method'><a href="wsemi.html#.isnbr">isnbr</a></li><li data-type='method'><a href="wsemi.html#.isnint">isnint</a></li><li data-type='method'><a href="wsemi.html#.isnull">isnull</a></li><li data-type='method'><a href="wsemi.html#.isnum">isnum</a></li><li data-type='method'><a href="wsemi.html#.isobj">isobj</a></li><li data-type='method'><a href="wsemi.html#.isobj0">isobj0</a></li><li data-type='method'><a href="wsemi.html#.isp0int">isp0int</a></li><li data-type='method'><a href="wsemi.html#.isp0num">isp0num</a></li><li data-type='method'><a href="wsemi.html#.ispint">ispint</a></li><li data-type='method'><a href="wsemi.html#.ispm">ispm</a></li><li data-type='method'><a href="wsemi.html#.isstr">isstr</a></li><li data-type='method'><a href="wsemi.html#.isstr0">isstr0</a></li><li data-type='method'><a href="wsemi.html#.isStrHasCapital">isStrHasCapital</a></li><li data-type='method'><a href="wsemi.html#.isStrHasLowerCase">isStrHasLowerCase</a></li><li data-type='method'><a href="wsemi.html#.isStrHasNumber">isStrHasNumber</a></li><li data-type='method'><a href="wsemi.html#.istime">istime</a></li><li data-type='method'><a href="wsemi.html#.istimeTZ">istimeTZ</a></li><li data-type='method'><a href="wsemi.html#.isu8arr">isu8arr</a></li><li data-type='method'><a href="wsemi.html#.isu16arr">isu16arr</a></li><li data-type='method'><a href="wsemi.html#.isundefined">isundefined</a></li><li data-type='method'><a href="wsemi.html#.isUserIdentify">isUserIdentify</a></li><li data-type='method'><a href="wsemi.html#.isUserName">isUserName</a></li><li data-type='method'><a href="wsemi.html#.isUserPW">isUserPW</a></li><li data-type='method'><a href="wsemi.html#.isWindow">isWindow</a></li><li data-type='method'><a href="wsemi.html#.j2o">j2o</a></li><li data-type='method'><a href="wsemi.html#.keysmat2ltdt">keysmat2ltdt</a></li><li data-type='method'><a href="wsemi.html#.ltdt2vrtsable">ltdt2vrtsable</a></li><li data-type='method'><a href="wsemi.html#.ltdtdiff">ltdtdiff</a></li><li data-type='method'><a href="wsemi.html#.ltdtkeys2mat">ltdtkeys2mat</a></li><li data-type='method'><a href="wsemi.html#.ltdtkeysheads2mat">ltdtkeysheads2mat</a></li><li data-type='method'><a href="wsemi.html#.ltdtmapping">ltdtmapping</a></li><li data-type='method'><a href="wsemi.html#.ltdtmerge">ltdtmerge</a></li><li data-type='method'><a href="wsemi.html#.ltdtpick">ltdtpick</a></li><li data-type='method'><a href="wsemi.html#.ltdtpull">ltdtpull</a></li><li data-type='method'><a href="wsemi.html#.mat2ltdt">mat2ltdt</a></li><li data-type='method'><a href="wsemi.html#.matat">matat</a></li><li data-type='method'><a href="wsemi.html#.now2str">now2str</a></li><li data-type='method'><a href="wsemi.html#.now2strp">now2strp</a></li><li data-type='method'><a href="wsemi.html#.nowDay2str">nowDay2str</a></li><li data-type='method'><a href="wsemi.html#.o2j">o2j</a></li><li data-type='method'><a href="wsemi.html#.obj2b64">obj2b64</a></li><li data-type='method'><a href="wsemi.html#.obj2pb64">obj2pb64</a></li><li data-type='method'><a href="wsemi.html#.obj2str">obj2str</a></li><li data-type='method'><a href="wsemi.html#.obj2stru8arr">obj2stru8arr</a></li><li data-type='method'><a href="wsemi.html#.obj2u8arr">obj2u8arr</a></li><li data-type='method'><a href="wsemi.html#.oo">oo</a></li><li data-type='method'><a href="wsemi.html#.openLink">openLink</a></li><li data-type='method'><a href="wsemi.html#.pb642obj">pb642obj</a></li><li data-type='method'><a href="wsemi.html#.pm2resolve">pm2resolve</a></li><li data-type='method'><a href="wsemi.html#.pmChain">pmChain</a></li><li data-type='method'><a href="wsemi.html#.pmHook">pmHook</a></li><li data-type='method'><a href="wsemi.html#.pmHookReject">pmHookReject</a></li><li data-type='method'><a href="wsemi.html#.pmIni">pmIni</a></li><li data-type='method'><a href="wsemi.html#.pmMap">pmMap</a></li><li data-type='method'><a href="wsemi.html#.pmQueue">pmQueue</a></li><li data-type='method'><a href="wsemi.html#.pmSeries">pmSeries</a></li><li data-type='method'><a href="wsemi.html#.pmThrottle">pmThrottle</a></li><li data-type='method'><a href="wsemi.html#.queue">queue</a></li><li data-type='method'><a href="wsemi.html#.rep">rep</a></li><li data-type='method'><a href="wsemi.html#.replace">replace</a></li><li data-type='method'><a href="wsemi.html#.replaceObj">replaceObj</a></li><li data-type='method'><a href="wsemi.html#.replacePlus">replacePlus</a></li><li data-type='method'><a href="wsemi.html#.repObj">repObj</a></li><li data-type='method'><a href="wsemi.html#.round">round</a></li><li data-type='method'><a href="wsemi.html#.sep">sep</a></li><li data-type='method'><a href="wsemi.html#.sepInt">sepInt</a></li><li data-type='method'><a href="wsemi.html#.sepTimeTZ">sepTimeTZ</a></li><li data-type='method'><a href="wsemi.html#.showImages">showImages</a></li><li data-type='method'><a href="wsemi.html#.showImagesDyn">showImagesDyn</a></li><li data-type='method'><a href="wsemi.html#.split">split</a></li><li data-type='method'><a href="wsemi.html#.str2aes">str2aes</a></li><li data-type='method'><a href="wsemi.html#.str2b64">str2b64</a></li><li data-type='method'><a href="wsemi.html#.str2md5">str2md5</a></li><li data-type='method'><a href="wsemi.html#.str2obj">str2obj</a></li><li data-type='method'><a href="wsemi.html#.str2sha512">str2sha512</a></li><li data-type='method'><a href="wsemi.html#.str2u8arr">str2u8arr</a></li><li data-type='method'><a href="wsemi.html#.strCompare">strCompare</a></li><li data-type='method'><a href="wsemi.html#.strdelleft">strdelleft</a></li><li data-type='method'><a href="wsemi.html#.strdelright">strdelright</a></li><li data-type='method'><a href="wsemi.html#.strFindFuzz">strFindFuzz</a></li><li data-type='method'><a href="wsemi.html#.strFindFuzzDyn">strFindFuzzDyn</a></li><li data-type='method'><a href="wsemi.html#.strFindSimilar">strFindSimilar</a></li><li data-type='method'><a href="wsemi.html#.strleft">strleft</a></li><li data-type='method'><a href="wsemi.html#.strmid">strmid</a></li><li data-type='method'><a href="wsemi.html#.strright">strright</a></li><li data-type='method'><a href="wsemi.html#.stru8arr2obj">stru8arr2obj</a></li><li data-type='method'><a href="wsemi.html#.time2day">time2day</a></li><li data-type='method'><a href="wsemi.html#.time2hour">time2hour</a></li><li data-type='method'><a href="wsemi.html#.time2min">time2min</a></li><li data-type='method'><a href="wsemi.html#.timeTZ2day">timeTZ2day</a></li><li data-type='method'><a href="wsemi.html#.timeTZ2expire">timeTZ2expire</a></li><li data-type='method'><a href="wsemi.html#.timeTZ2hour">timeTZ2hour</a></li><li data-type='method'><a href="wsemi.html#.timeTZ2min">timeTZ2min</a></li><li data-type='method'><a href="wsemi.html#.timeTZ2past">timeTZ2past</a></li><li data-type='method'><a href="wsemi.html#.tinycolor">tinycolor</a></li><li data-type='method'><a href="wsemi.html#.treeObj">treeObj</a></li><li data-type='method'><a href="wsemi.html#.trim">trim</a></li><li data-type='method'><a href="wsemi.html#.u8arr2ab">u8arr2ab</a></li><li data-type='method'><a href="wsemi.html#.u8arr2b64">u8arr2b64</a></li><li data-type='method'><a href="wsemi.html#.u8arr2blob">u8arr2blob</a></li><li data-type='method'><a href="wsemi.html#.u8arr2bs">u8arr2bs</a></li><li data-type='method'><a href="wsemi.html#.u8arr2obj">u8arr2obj</a></li><li data-type='method'><a href="wsemi.html#.u8arr2str">u8arr2str</a></li><li data-type='method'><a href="wsemi.html#.u8arr2u16arr">u8arr2u16arr</a></li><li data-type='method'><a href="wsemi.html#.u16arr2b64">u16arr2b64</a></li><li data-type='method'><a href="wsemi.html#.u16arr2u8arr">u16arr2u8arr</a></li><li data-type='method'><a href="wsemi.html#.urlParse">urlParse</a></li><li data-type='method'><a href="wsemi.html#.verifyValue">verifyValue</a></li><li data-type='method'><a href="wsemi.html#.waitFun">waitFun</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#composeTreeObj">composeTreeObj</a></li><li><a href="global.html#flattenTreeObj">flattenTreeObj</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">tinycolor.mjs</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>let trimLeft = /^\s+/
let trimRight = /\s+$/
let tinyCounter = 0
let mathRound = Math.round
let mathMin = Math.min
let mathMax = Math.max
let mathRandom = Math.random


/**
 * 顏色處理，修改自TinyColor
 *
 * Fork: {@link https://github.com/bgrins/TinyColor/blob/master/tinycolor.js TinyColor 1.4.1}
 *
 * Unit Test: {@link https://github.com/yuda-lyu/wsemi/blob/master/test/ab2blob.test.js Github}
 * @memberOf wsemi
 * @param {String|Object} color 輸入顏色字串或物件
 * @returns {Object} 回傳TinyColor物件
 * @example
 * //see https://github.com/bgrins/TinyColor/blob/master/tinycolor.js
 */
function tinycolor(color) {

    color = (color) || ''
    // opts = opts || { }

    // If input is already a tinycolor, return itself
    if (color instanceof tinycolor) {
        return color
    }
    // If we are called as a function, call using new instead
    if (!(this instanceof tinycolor)) {
        let T = tinycolor
        return new T(color) //eslint: new需要字首大寫
    }

    let rgb = inputToRGB(color)
    this._originalInput = color
    this._r = rgb.r
    this._g = rgb.g
    this._b = rgb.b
    this._a = rgb.a
    this._roundA = mathRound(100 * this._a) / 100
    //this._format = opts.format || rgb.format
    this._format = rgb.format
    // this._gradientType = opts.gradientType

    // Don't let the range of [0,255] come back in [0,1].
    // Potentially lose a little bit of precision here, but will fix issues where
    // .5 gets interpreted as half of the total, instead of half of 1
    // If it was supposed to be 128, this was already taken care of by `inputToRgb`
    if (this._r &lt; 1) {
        this._r = mathRound(this._r)
    }
    if (this._g &lt; 1) {
        this._g = mathRound(this._g)
    }
    if (this._b &lt; 1) {
        this._b = mathRound(this._b)
    }

    this._ok = rgb.ok
    this._tc_id = tinyCounter++
}

tinycolor.prototype = {
    isDark: function() {
        return this.getBrightness() &lt; 128
    },
    isLight: function() {
        return !this.isDark()
    },
    isValid: function() {
        return this._ok
    },
    getOriginalInput: function() {
        return this._originalInput
    },
    // getFormat: function() {
    //     return this._format
    // },
    getAlpha: function() {
        return this._a
    },
    getBrightness: function() {
        //http://www.w3.org/TR/AERT#color-contrast
        let rgb = this.toRgb()
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000
    },
    getLuminance: function() {
        //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
        let rgb = this.toRgb()
        let RsRGB, GsRGB, BsRGB, R, G, B
        RsRGB = rgb.r / 255
        GsRGB = rgb.g / 255
        BsRGB = rgb.b / 255

        if (RsRGB &lt;= 0.03928) {
            R = RsRGB / 12.92
        }
        else {
            R = Math.pow(((RsRGB + 0.055) / 1.055), 2.4)
        }
        if (GsRGB &lt;= 0.03928) {
            G = GsRGB / 12.92
        }
        else {
            G = Math.pow(((GsRGB + 0.055) / 1.055), 2.4)
        }
        if (BsRGB &lt;= 0.03928) {
            B = BsRGB / 12.92
        }
        else {
            B = Math.pow(((BsRGB + 0.055) / 1.055), 2.4)
        }
        return (0.2126 * R) + (0.7152 * G) + (0.0722 * B)
    },
    setAlpha: function(value) {
        this._a = boundAlpha(value)
        this._roundA = mathRound(100 * this._a) / 100
        return this
    },
    toHsv: function() {
        let hsv = rgbToHsv(this._r, this._g, this._b)
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a }
    },
    toHsvString: function() {
        let hsv = rgbToHsv(this._r, this._g, this._b)
        let h = mathRound(hsv.h * 360); let s = mathRound(hsv.s * 100); let v = mathRound(hsv.v * 100)
        return (this._a === 1)
            ? 'hsv(' + h + ', ' + s + '%, ' + v + '%)'
            : 'hsva(' + h + ', ' + s + '%, ' + v + '%, ' + this._roundA + ')'
    },
    toHsl: function() {
        let hsl = rgbToHsl(this._r, this._g, this._b)
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a }
    },
    toHslString: function() {
        let hsl = rgbToHsl(this._r, this._g, this._b)
        let h = mathRound(hsl.h * 360); let s = mathRound(hsl.s * 100); let l = mathRound(hsl.l * 100)
        return (this._a === 1)
            ? 'hsl(' + h + ', ' + s + '%, ' + l + '%)'
            : 'hsla(' + h + ', ' + s + '%, ' + l + '%, ' + this._roundA + ')'
    },
    toHex: function(allow3Char) {
        return rgbToHex(this._r, this._g, this._b, allow3Char)
    },
    toHexString: function(allow3Char) {
        return '#' + this.toHex(allow3Char)
    },
    toHex8: function(allow4Char) {
        return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char)
    },
    toHex8String: function(allow4Char) {
        return '#' + this.toHex8(allow4Char)
    },
    toRgb: function() {
        return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a }
    },
    toRgbString: function() {
        return (this._a === 1)
            ? 'rgb(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ')'
            : 'rgba(' + mathRound(this._r) + ', ' + mathRound(this._g) + ', ' + mathRound(this._b) + ', ' + this._roundA + ')'
    },
    toPercentageRgb: function() {
        return { r: mathRound(bound01(this._r, 255) * 100) + '%', g: mathRound(bound01(this._g, 255) * 100) + '%', b: mathRound(bound01(this._b, 255) * 100) + '%', a: this._a }
    },
    toPercentageRgbString: function() {
        return (this._a === 1)
            ? 'rgb(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%)'
            : 'rgba(' + mathRound(bound01(this._r, 255) * 100) + '%, ' + mathRound(bound01(this._g, 255) * 100) + '%, ' + mathRound(bound01(this._b, 255) * 100) + '%, ' + this._roundA + ')'
    },
    toName: function() {
        if (this._a === 0) {
            return 'transparent'
        }

        if (this._a &lt; 1) {
            return false
        }

        return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false
    },
    // toFilter: function(secondColor) {
    //     let hex8String = '#' + rgbaToArgbHex(this._r, this._g, this._b, this._a)
    //     let secondHex8String = hex8String
    //     let gradientType = this._gradientType ? 'GradientType = 1, ' : ''

    //     if (secondColor) {
    //         let s = tinycolor(secondColor)
    //         secondHex8String = '#' + rgbaToArgbHex(s._r, s._g, s._b, s._a)
    //     }

    //     return 'progid:DXImageTransform.Microsoft.gradient(' + gradientType + 'startColorstr=' + hex8String + ',endColorstr=' + secondHex8String + ')'
    // },
    toString: function(format) {
        let formatSet = !!format
        format = format || this._format

        let formattedString = false
        let hasAlpha = this._a &lt; 1 &amp;&amp; this._a >= 0
        let needsAlphaFormat = !formatSet &amp;&amp; hasAlpha &amp;&amp; (format === 'hex' || format === 'hex6' || format === 'hex3' || format === 'hex4' || format === 'hex8' || format === 'name')

        if (needsAlphaFormat) {
            // Special case for "transparent", all other non-alpha formats
            // will return rgba when there is transparency.
            if (format === 'name' &amp;&amp; this._a === 0) {
                return this.toName()
            }
            return this.toRgbString()
        }
        if (format === 'rgb') {
            formattedString = this.toRgbString()
        }
        if (format === 'prgb') {
            formattedString = this.toPercentageRgbString()
        }
        if (format === 'hex' || format === 'hex6') {
            formattedString = this.toHexString()
        }
        if (format === 'hex3') {
            formattedString = this.toHexString(true)
        }
        if (format === 'hex4') {
            formattedString = this.toHex8String(true)
        }
        if (format === 'hex8') {
            formattedString = this.toHex8String()
        }
        if (format === 'name') {
            formattedString = this.toName()
        }
        if (format === 'hsl') {
            formattedString = this.toHslString()
        }
        if (format === 'hsv') {
            formattedString = this.toHsvString()
        }

        return formattedString || this.toHexString()
    },
    clone: function() {
        return tinycolor(this.toString())
    },

    _applyModification: function(fn, args) {
        let color = fn.apply(null, [this].concat([].slice.call(args)))
        this._r = color._r
        this._g = color._g
        this._b = color._b
        this.setAlpha(color._a)
        return this
    },
    lighten: function() {
        return this._applyModification(lighten, arguments)
    },
    brighten: function() {
        return this._applyModification(brighten, arguments)
    },
    darken: function() {
        return this._applyModification(darken, arguments)
    },
    desaturate: function() {
        return this._applyModification(desaturate, arguments)
    },
    saturate: function() {
        return this._applyModification(saturate, arguments)
    },
    greyscale: function() {
        return this._applyModification(greyscale, arguments)
    },
    spin: function() {
        return this._applyModification(spin, arguments)
    },

    _applyCombination: function(fn, args) {
        return fn.apply(null, [this].concat([].slice.call(args)))
    },
    analogous: function() {
        return this._applyCombination(analogous, arguments)
    },
    complement: function() {
        return this._applyCombination(complement, arguments)
    },
    monochromatic: function() {
        return this._applyCombination(monochromatic, arguments)
    },
    splitcomplement: function() {
        return this._applyCombination(splitcomplement, arguments)
    },
    triad: function() {
        return this._applyCombination(triad, arguments)
    },
    tetrad: function() {
        return this._applyCombination(tetrad, arguments)
    }
}

// If input is an object, force 1 into "1.0" to handle ratios properly
// String input requires "1.0" as input, so 1 will be treated as 1
tinycolor.fromRatio = function(color) {
    if (typeof color === 'object') {
        let newColor = {}
        for (let i in color) {
            //if (color.hasOwnProperty(i)) {
            if (Object.prototype.hasOwnProperty.call(color, i)) {
                if (i === 'a') {
                    newColor[i] = color[i]
                }
                else {
                    newColor[i] = convertToPercentage(color[i])
                }
            }
        }
        color = newColor
    }

    return tinycolor(color)
}

// Given a string or object, convert that input to RGB
// Possible string inputs:
//
//     "red"
//     "#f00" or "f00"
//     "#ff0000" or "ff0000"
//     "#ff000000" or "ff000000"
//     "rgb 255 0 0" or "rgb (255, 0, 0)"
//     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
//     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
//     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
//     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
//     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
//     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
//
function inputToRGB(color) {

    let rgb = { r: 0, g: 0, b: 0 }
    let a = 1
    let s = null
    let v = null
    let l = null
    let ok = false
    let format = false

    if (typeof color === 'string') {
        color = stringInputToObject(color)
    }

    if (typeof color === 'object') {
        if (isValidCSSUnit(color.r) &amp;&amp; isValidCSSUnit(color.g) &amp;&amp; isValidCSSUnit(color.b)) {
            rgb = rgbToRgb(color.r, color.g, color.b)
            ok = true
            format = String(color.r).substr(-1) === '%' ? 'prgb' : 'rgb'
        }
        else if (isValidCSSUnit(color.h) &amp;&amp; isValidCSSUnit(color.s) &amp;&amp; isValidCSSUnit(color.v)) {
            s = convertToPercentage(color.s)
            v = convertToPercentage(color.v)
            rgb = hsvToRgb(color.h, s, v)
            ok = true
            format = 'hsv'
        }
        else if (isValidCSSUnit(color.h) &amp;&amp; isValidCSSUnit(color.s) &amp;&amp; isValidCSSUnit(color.l)) {
            s = convertToPercentage(color.s)
            l = convertToPercentage(color.l)
            rgb = hslToRgb(color.h, s, l)
            ok = true
            format = 'hsl'
        }

        //if (color.hasOwnProperty('a')) {
        if (Object.prototype.hasOwnProperty.call(color, 'a')) {
            a = color.a
        }
    }

    a = boundAlpha(a)

    return {
        ok: ok,
        format: color.format || format,
        r: mathMin(255, mathMax(rgb.r, 0)),
        g: mathMin(255, mathMax(rgb.g, 0)),
        b: mathMin(255, mathMax(rgb.b, 0)),
        a: a
    }
}


// Conversion Functions
// --------------------

// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
// &lt;http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

// `rgbToRgb`
// Handle bounds / percentage checking to conform to CSS color spec
// &lt;http://www.w3.org/TR/css3-color/>
// *Assumes:* r, g, b in [0, 255] or [0, 1]
// *Returns:* { r, g, b } in [0, 255]
function rgbToRgb(r, g, b) {
    return {
        r: bound01(r, 255) * 255,
        g: bound01(g, 255) * 255,
        b: bound01(b, 255) * 255
    }
}

// `rgbToHsl`
// Converts an RGB color value to HSL.
// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
// *Returns:* { h, s, l } in [0,1]
function rgbToHsl(r, g, b) {

    r = bound01(r, 255)
    g = bound01(g, 255)
    b = bound01(b, 255)

    let max = mathMax(r, g, b); let min = mathMin(r, g, b)
    let h; let s; let l = (max + min) / 2

    if (max === min) {
        h = s = 0 // achromatic
    }
    else {
        let d = max - min
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min)
        switch (max) {
        case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break
        case g: h = (b - r) / d + 2; break
        case b: h = (r - g) / d + 4; break
        }

        h /= 6
    }

    return { h: h, s: s, l: l }
}

// `hslToRgb`
// Converts an HSL color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hslToRgb(h, s, l) {
    let r, g, b

    h = bound01(h, 360)
    s = bound01(s, 100)
    l = bound01(l, 100)

    function hue2rgb(p, q, t) {
        if (t &lt; 0) t += 1
        if (t > 1) t -= 1
        if (t &lt; 1 / 6) return p + (q - p) * 6 * t
        if (t &lt; 1 / 2) return q
        if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6
        return p
    }

    if (s === 0) {
        r = g = b = l // achromatic
    }
    else {
        let q = l &lt; 0.5 ? l * (1 + s) : l + s - l * s
        let p = 2 * l - q
        r = hue2rgb(p, q, h + 1 / 3)
        g = hue2rgb(p, q, h)
        b = hue2rgb(p, q, h - 1 / 3)
    }

    return { r: r * 255, g: g * 255, b: b * 255 }
}

// `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]
function rgbToHsv(r, g, b) {

    r = bound01(r, 255)
    g = bound01(g, 255)
    b = bound01(b, 255)

    let max = mathMax(r, g, b); let min = mathMin(r, g, b)
    let h; let s; let v = max

    let d = max - min
    s = max === 0 ? 0 : d / max

    if (max === min) {
        h = 0 // achromatic
    }
    else {
        switch (max) {
        case r: h = (g - b) / d + (g &lt; b ? 6 : 0); break
        case g: h = (b - r) / d + 2; break
        case b: h = (r - g) / d + 4; break
        }
        h /= 6
    }
    return { h: h, s: s, v: v }
}

// `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]
function hsvToRgb(h, s, v) {

    h = bound01(h, 360) * 6
    s = bound01(s, 100)
    v = bound01(v, 100)

    let i = Math.floor(h)
    let f = h - i
    let p = v * (1 - s)
    let q = v * (1 - f * s)
    let t = v * (1 - (1 - f) * s)
    let mod = i % 6
    let r = [v, q, p, p, t, v][mod]
    let g = [t, v, v, q, p, p][mod]
    let b = [p, p, t, v, v, q][mod]

    return { r: r * 255, g: g * 255, b: b * 255 }
}

// `rgbToHex`
// Converts an RGB color to hex
// Assumes r, g, and b are contained in the set [0, 255]
// Returns a 3 or 6 character hex
function rgbToHex(r, g, b, allow3Char) {

    let hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16))
    ]

    // Return a 3 character hex if possible
    if (allow3Char &amp;&amp; hex[0].charAt(0) === hex[0].charAt(1) &amp;&amp; hex[1].charAt(0) === hex[1].charAt(1) &amp;&amp; hex[2].charAt(0) === hex[2].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0)
    }

    return hex.join('')
}

// `rgbaToHex`
// Converts an RGBA color plus alpha transparency to hex
// Assumes r, g, b are contained in the set [0, 255] and
// a in [0, 1]. Returns a 4 or 8 character rgba hex
function rgbaToHex(r, g, b, a, allow4Char) {

    let hex = [
        pad2(mathRound(r).toString(16)),
        pad2(mathRound(g).toString(16)),
        pad2(mathRound(b).toString(16)),
        pad2(convertDecimalToHex(a))
    ]

    // Return a 4 character hex if possible
    if (allow4Char &amp;&amp; hex[0].charAt(0) === hex[0].charAt(1) &amp;&amp; hex[1].charAt(0) === hex[1].charAt(1) &amp;&amp; hex[2].charAt(0) === hex[2].charAt(1) &amp;&amp; hex[3].charAt(0) === hex[3].charAt(1)) {
        return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0)
    }

    return hex.join('')
}

// `rgbaToArgbHex`
// Converts an RGBA color to an ARGB Hex8 string
// Rarely used, but required for "toFilter()"
// function rgbaToArgbHex(r, g, b, a) {

//     let hex = [
//         pad2(convertDecimalToHex(a)),
//         pad2(mathRound(r).toString(16)),
//         pad2(mathRound(g).toString(16)),
//         pad2(mathRound(b).toString(16))
//     ]

//     return hex.join('')
// }

// `equals`
// Can be called with any tinycolor input
tinycolor.equals = function (color1, color2) {
    if (!color1 || !color2) {
        return false
    }
    return tinycolor(color1).toRgbString() === tinycolor(color2).toRgbString()
}

tinycolor.random = function() {
    return tinycolor.fromRatio({
        r: mathRandom(),
        g: mathRandom(),
        b: mathRandom()
    })
}


// Modification Functions
// ----------------------
// Thanks to less.js for some of the basics here
// &lt;https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

function desaturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10)
    let hsl = tinycolor(color).toHsl()
    hsl.s -= amount / 100
    hsl.s = clamp01(hsl.s)
    return tinycolor(hsl)
}

function saturate(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10)
    let hsl = tinycolor(color).toHsl()
    hsl.s += amount / 100
    hsl.s = clamp01(hsl.s)
    return tinycolor(hsl)
}

function greyscale(color) {
    return tinycolor(color).desaturate(100)
}

function lighten (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10)
    let hsl = tinycolor(color).toHsl()
    hsl.l += amount / 100
    hsl.l = clamp01(hsl.l)
    return tinycolor(hsl)
}

function brighten(color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10)
    let rgb = tinycolor(color).toRgb()
    rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100))))
    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100))))
    rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100))))
    return tinycolor(rgb)
}

function darken (color, amount) {
    amount = (amount === 0) ? 0 : (amount || 10)
    let hsl = tinycolor(color).toHsl()
    hsl.l -= amount / 100
    hsl.l = clamp01(hsl.l)
    return tinycolor(hsl)
}

// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
// Values outside of this range will be wrapped into this range.
function spin(color, amount) {
    let hsl = tinycolor(color).toHsl()
    let hue = (hsl.h + amount) % 360
    hsl.h = hue &lt; 0 ? 360 + hue : hue
    return tinycolor(hsl)
}

// Combination Functions
// ---------------------
// Thanks to jQuery xColor for some of the ideas behind these
// &lt;https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

function complement(color) {
    let hsl = tinycolor(color).toHsl()
    hsl.h = (hsl.h + 180) % 360
    return tinycolor(hsl)
}

function triad(color) {
    let hsl = tinycolor(color).toHsl()
    let h = hsl.h
    return [
        tinycolor(color),
        tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
    ]
}

function tetrad(color) {
    let hsl = tinycolor(color).toHsl()
    let h = hsl.h
    return [
        tinycolor(color),
        tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
    ]
}

function splitcomplement(color) {
    let hsl = tinycolor(color).toHsl()
    let h = hsl.h
    return [
        tinycolor(color),
        tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),
        tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l })
    ]
}

function analogous(color, results, slices) {
    results = results || 6
    slices = slices || 30

    let hsl = tinycolor(color).toHsl()
    let part = 360 / slices
    let ret = [tinycolor(color)]

    for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results;) {
        hsl.h = (hsl.h + part) % 360
        ret.push(tinycolor(hsl))
    }
    return ret
}

function monochromatic(color, results) {
    results = results || 6
    let hsv = tinycolor(color).toHsv()
    let h = hsv.h; let s = hsv.s; let v = hsv.v
    let ret = []
    let modification = 1 / results

    while (results--) {
        ret.push(tinycolor({ h: h, s: s, v: v }))
        v = (v + modification) % 1
    }

    return ret
}

// Utility Functions
// ---------------------

tinycolor.mix = function(color1, color2, amount) {
    amount = (amount === 0) ? 0 : (amount || 50)

    let rgb1 = tinycolor(color1).toRgb()
    let rgb2 = tinycolor(color2).toRgb()

    let p = amount / 100

    let rgba = {
        r: ((rgb2.r - rgb1.r) * p) + rgb1.r,
        g: ((rgb2.g - rgb1.g) * p) + rgb1.g,
        b: ((rgb2.b - rgb1.b) * p) + rgb1.b,
        a: ((rgb2.a - rgb1.a) * p) + rgb1.a
    }

    return tinycolor(rgba)
}


// Readability Functions
// ---------------------
// &lt;http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)

// `contrast`
// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)
tinycolor.readability = function(color1, color2) {
    let c1 = tinycolor(color1)
    let c2 = tinycolor(color2)
    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05)
}

// `isReadable`
// Ensure that foreground and background color combinations meet WCAG2 guidelines.
// The third argument is an optional Object.
//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';
//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.
// If the entire object is absent, isReadable defaults to {level:"AA",size:"small"}.

// *Example*
//    tinycolor.isReadable("#000", "#111") => false
//    tinycolor.isReadable("#000", "#111",{level:"AA",size:"large"}) => false
tinycolor.isReadable = function(color1, color2, wcag2) {
    let readability = tinycolor.readability(color1, color2)
    let wcag2Parms, out

    out = false

    wcag2Parms = validateWCAG2Parms(wcag2)
    switch (wcag2Parms.level + wcag2Parms.size) {
    case 'AAsmall':
    case 'AAAlarge':
        out = readability >= 4.5
        break
    case 'AAlarge':
        out = readability >= 3
        break
    case 'AAAsmall':
        out = readability >= 7
        break
    }
    return out

}

// `mostReadable`
// Given a base color and a list of possible foreground or background
// colors for that base, returns the most readable color.
// Optionally returns Black or White if the most readable color is unreadable.
// *Example*
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:false}).toHexString(); // "#112255"
//    tinycolor.mostReadable(tinycolor.mostReadable("#123", ["#124", "#125"],{includeFallbackColors:true}).toHexString();  // "#ffffff"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"large"}).toHexString(); // "#faf3f3"
//    tinycolor.mostReadable("#a8015a", ["#faf3f3"],{includeFallbackColors:true,level:"AAA",size:"small"}).toHexString(); // "#ffffff"
tinycolor.mostReadable = function(baseColor, colorList, args) {
    let bestColor = null
    let bestScore = 0
    let readability
    let includeFallbackColors, level, size
    args = args || {}
    includeFallbackColors = args.includeFallbackColors
    level = args.level
    size = args.size

    for (let i = 0; i &lt; colorList.length; i++) {
        readability = tinycolor.readability(baseColor, colorList[i])
        if (readability > bestScore) {
            bestScore = readability
            bestColor = tinycolor(colorList[i])
        }
    }

    if (tinycolor.isReadable(baseColor, bestColor, { 'level': level, 'size': size }) || !includeFallbackColors) {
        return bestColor
    }
    else {
        args.includeFallbackColors = false
        return tinycolor.mostReadable(baseColor, ['#fff', '#000'], args)
    }
}


// Big List of Colors
// ------------------
// &lt;http://www.w3.org/TR/css3-color/#svg-color>
let names = tinycolor.names = {
    aliceblue: 'f0f8ff',
    antiquewhite: 'faebd7',
    aqua: '0ff',
    aquamarine: '7fffd4',
    azure: 'f0ffff',
    beige: 'f5f5dc',
    bisque: 'ffe4c4',
    black: '000',
    blanchedalmond: 'ffebcd',
    blue: '00f',
    blueviolet: '8a2be2',
    brown: 'a52a2a',
    burlywood: 'deb887',
    burntsienna: 'ea7e5d',
    cadetblue: '5f9ea0',
    chartreuse: '7fff00',
    chocolate: 'd2691e',
    coral: 'ff7f50',
    cornflowerblue: '6495ed',
    cornsilk: 'fff8dc',
    crimson: 'dc143c',
    cyan: '0ff',
    darkblue: '00008b',
    darkcyan: '008b8b',
    darkgoldenrod: 'b8860b',
    darkgray: 'a9a9a9',
    darkgreen: '006400',
    darkgrey: 'a9a9a9',
    darkkhaki: 'bdb76b',
    darkmagenta: '8b008b',
    darkolivegreen: '556b2f',
    darkorange: 'ff8c00',
    darkorchid: '9932cc',
    darkred: '8b0000',
    darksalmon: 'e9967a',
    darkseagreen: '8fbc8f',
    darkslateblue: '483d8b',
    darkslategray: '2f4f4f',
    darkslategrey: '2f4f4f',
    darkturquoise: '00ced1',
    darkviolet: '9400d3',
    deeppink: 'ff1493',
    deepskyblue: '00bfff',
    dimgray: '696969',
    dimgrey: '696969',
    dodgerblue: '1e90ff',
    firebrick: 'b22222',
    floralwhite: 'fffaf0',
    forestgreen: '228b22',
    fuchsia: 'f0f',
    gainsboro: 'dcdcdc',
    ghostwhite: 'f8f8ff',
    gold: 'ffd700',
    goldenrod: 'daa520',
    gray: '808080',
    green: '008000',
    greenyellow: 'adff2f',
    grey: '808080',
    honeydew: 'f0fff0',
    hotpink: 'ff69b4',
    indianred: 'cd5c5c',
    indigo: '4b0082',
    ivory: 'fffff0',
    khaki: 'f0e68c',
    lavender: 'e6e6fa',
    lavenderblush: 'fff0f5',
    lawngreen: '7cfc00',
    lemonchiffon: 'fffacd',
    lightblue: 'add8e6',
    lightcoral: 'f08080',
    lightcyan: 'e0ffff',
    lightgoldenrodyellow: 'fafad2',
    lightgray: 'd3d3d3',
    lightgreen: '90ee90',
    lightgrey: 'd3d3d3',
    lightpink: 'ffb6c1',
    lightsalmon: 'ffa07a',
    lightseagreen: '20b2aa',
    lightskyblue: '87cefa',
    lightslategray: '789',
    lightslategrey: '789',
    lightsteelblue: 'b0c4de',
    lightyellow: 'ffffe0',
    lime: '0f0',
    limegreen: '32cd32',
    linen: 'faf0e6',
    magenta: 'f0f',
    maroon: '800000',
    mediumaquamarine: '66cdaa',
    mediumblue: '0000cd',
    mediumorchid: 'ba55d3',
    mediumpurple: '9370db',
    mediumseagreen: '3cb371',
    mediumslateblue: '7b68ee',
    mediumspringgreen: '00fa9a',
    mediumturquoise: '48d1cc',
    mediumvioletred: 'c71585',
    midnightblue: '191970',
    mintcream: 'f5fffa',
    mistyrose: 'ffe4e1',
    moccasin: 'ffe4b5',
    navajowhite: 'ffdead',
    navy: '000080',
    oldlace: 'fdf5e6',
    olive: '808000',
    olivedrab: '6b8e23',
    orange: 'ffa500',
    orangered: 'ff4500',
    orchid: 'da70d6',
    palegoldenrod: 'eee8aa',
    palegreen: '98fb98',
    paleturquoise: 'afeeee',
    palevioletred: 'db7093',
    papayawhip: 'ffefd5',
    peachpuff: 'ffdab9',
    peru: 'cd853f',
    pink: 'ffc0cb',
    plum: 'dda0dd',
    powderblue: 'b0e0e6',
    purple: '800080',
    rebeccapurple: '663399',
    red: 'f00',
    rosybrown: 'bc8f8f',
    royalblue: '4169e1',
    saddlebrown: '8b4513',
    salmon: 'fa8072',
    sandybrown: 'f4a460',
    seagreen: '2e8b57',
    seashell: 'fff5ee',
    sienna: 'a0522d',
    silver: 'c0c0c0',
    skyblue: '87ceeb',
    slateblue: '6a5acd',
    slategray: '708090',
    slategrey: '708090',
    snow: 'fffafa',
    springgreen: '00ff7f',
    steelblue: '4682b4',
    tan: 'd2b48c',
    teal: '008080',
    thistle: 'd8bfd8',
    tomato: 'ff6347',
    turquoise: '40e0d0',
    violet: 'ee82ee',
    wheat: 'f5deb3',
    white: 'fff',
    whitesmoke: 'f5f5f5',
    yellow: 'ff0',
    yellowgreen: '9acd32'
}

// Make it easy to access colors via `hexNames[hex]`
let hexNames = tinycolor.hexNames = flip(names)


// Utilities
// ---------

// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
function flip(o) {
    let flipped = { }
    for (let i in o) {
        //if (o.hasOwnProperty(i)) {
        if (Object.prototype.hasOwnProperty.call(o, i)) {
            flipped[o[i]] = i
        }
    }
    return flipped
}

// Return a valid alpha value [0,1] with all invalid values being set to 1
function boundAlpha(a) {
    a = parseFloat(a)

    if (isNaN(a) || a &lt; 0 || a > 1) {
        a = 1
    }

    return a
}

// Take input from [0, n] and return it as [0, 1]
function bound01(n, max) {
    if (isOnePointZero(n)) {
        n = '100%'
    }

    let processPercent = isPercentage(n)
    n = mathMin(max, mathMax(0, parseFloat(n)))

    // Automatically convert percentage into number
    if (processPercent) {
        n = parseInt(n * max, 10) / 100
    }

    // Handle floating point rounding errors
    if ((Math.abs(n - max) &lt; 0.000001)) {
        return 1
    }

    // Convert into [0, 1] range if it isn't already
    return (n % max) / parseFloat(max)
}

// Force a number between 0 and 1
function clamp01(val) {
    return mathMin(1, mathMax(0, val))
}

// Parse a base-16 hex value into a base-10 integer
function parseIntFromHex(val) {
    return parseInt(val, 16)
}

// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// &lt;http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
function isOnePointZero(n) {
    return typeof n === 'string' &amp;&amp; n.indexOf('.') !== -1 &amp;&amp; parseFloat(n) === 1
}

// Check to see if string passed in is a percentage
function isPercentage(n) {
    return typeof n === 'string' &amp;&amp; n.indexOf('%') !== -1
}

// Force a hex value to have 2 characters
function pad2(c) {
    return c.length === 1 ? '0' + c : '' + c
}

// Replace a decimal with it's percentage value
function convertToPercentage(n) {
    if (n &lt;= 1) {
        n = (n * 100) + '%'
    }

    return n
}

// Converts a decimal to a hex value
function convertDecimalToHex(d) {
    return Math.round(parseFloat(d) * 255).toString(16)
}
// Converts a hex value to a decimal
function convertHexToDecimal(h) {
    return (parseIntFromHex(h) / 255)
}

let matchers = (function() {

    // &lt;http://www.w3.org/TR/css3-values/#integers>
    let CSS_INTEGER = '[-\\+]?\\d+%?'

    // &lt;http://www.w3.org/TR/css3-values/#number-value>
    let CSS_NUMBER = '[-\\+]?\\d*\\.\\d+%?'

    // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
    let CSS_UNIT = '(?:' + CSS_NUMBER + ')|(?:' + CSS_INTEGER + ')'

    // Actual matching.
    // Parentheses and commas are optional, but not required.
    // Whitespace can take the place of commas or opening paren
    let PERMISSIVE_MATCH3 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?'
    let PERMISSIVE_MATCH4 = '[\\s|\\(]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')[,|\\s]+(' + CSS_UNIT + ')\\s*\\)?'

    return {
        CSS_UNIT: new RegExp(CSS_UNIT),
        rgb: new RegExp('rgb' + PERMISSIVE_MATCH3),
        rgba: new RegExp('rgba' + PERMISSIVE_MATCH4),
        hsl: new RegExp('hsl' + PERMISSIVE_MATCH3),
        hsla: new RegExp('hsla' + PERMISSIVE_MATCH4),
        hsv: new RegExp('hsv' + PERMISSIVE_MATCH3),
        hsva: new RegExp('hsva' + PERMISSIVE_MATCH4),
        hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
        hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
        hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
    }
})()

// `isValidCSSUnit`
// Take in a single string / number and check to see if it looks like a CSS unit
// (see `matchers` above for definition).
function isValidCSSUnit(color) {
    return !!matchers.CSS_UNIT.exec(color)
}

// `stringInputToObject`
// Permissive string parsing.  Take in a number of formats, and output an object
// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
function stringInputToObject(color) {

    color = color.replace(trimLeft, '').replace(trimRight, '').toLowerCase()
    let named = false
    if (names[color]) {
        color = names[color]
        named = true
    }
    else if (color === 'transparent') {
        return { r: 0, g: 0, b: 0, a: 0, format: 'name' }
    }

    // Try to match string input using regular expressions.
    // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
    // Just return an object and let the conversion functions handle that.
    // This way the result will be the same whether the tinycolor is initialized with string or object.
    let match
    if ((match = matchers.rgb.exec(color))) {
        return { r: match[1], g: match[2], b: match[3] }
    }
    if ((match = matchers.rgba.exec(color))) {
        return { r: match[1], g: match[2], b: match[3], a: match[4] }
    }
    if ((match = matchers.hsl.exec(color))) {
        return { h: match[1], s: match[2], l: match[3] }
    }
    if ((match = matchers.hsla.exec(color))) {
        return { h: match[1], s: match[2], l: match[3], a: match[4] }
    }
    if ((match = matchers.hsv.exec(color))) {
        return { h: match[1], s: match[2], v: match[3] }
    }
    if ((match = matchers.hsva.exec(color))) {
        return { h: match[1], s: match[2], v: match[3], a: match[4] }
    }
    if ((match = matchers.hex8.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            a: convertHexToDecimal(match[4]),
            format: named ? 'name' : 'hex8'
        }
    }
    if ((match = matchers.hex6.exec(color))) {
        return {
            r: parseIntFromHex(match[1]),
            g: parseIntFromHex(match[2]),
            b: parseIntFromHex(match[3]),
            format: named ? 'name' : 'hex'
        }
    }
    if ((match = matchers.hex4.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            a: convertHexToDecimal(match[4] + '' + match[4]),
            format: named ? 'name' : 'hex8'
        }
    }
    if ((match = matchers.hex3.exec(color))) {
        return {
            r: parseIntFromHex(match[1] + '' + match[1]),
            g: parseIntFromHex(match[2] + '' + match[2]),
            b: parseIntFromHex(match[3] + '' + match[3]),
            format: named ? 'name' : 'hex'
        }
    }

    return false
}

function validateWCAG2Parms(parms) {
// return valid WCAG2 parms for isReadable.
// If input parms are invalid, return {"level":"AA", "size":"small"}
    let level, size
    parms = parms || { 'level': 'AA', 'size': 'small' }
    level = (parms.level || 'AA').toUpperCase()
    size = (parms.size || 'small').toLowerCase()
    if (level !== 'AA' &amp;&amp; level !== 'AAA') {
        level = 'AA'
    }
    if (size !== 'small' &amp;&amp; size !== 'large') {
        size = 'small'
    }
    return { 'level': level, 'size': size }
}


export default tinycolor
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.6</a> on Wed Dec 30 2020 22:23:18 GMT+0800 (台北標準時間) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
